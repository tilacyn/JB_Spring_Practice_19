# Parallel Dijkstra Algorithm

В рамках этого тестового задания вам необходимо реализовать параллельную версию алгоритма Дейкстры для поиска кратчайшего пути в графе. Файл `Graph.kt` содержит классы `Node` и `Edge`, описывающие граф. Вы можете использовать поле `Node.distance` для того, чтобы хранить расстояние до текущей вершины во время поиска; функция `clearNodes(..)` сбрасывает эти расстояния на `Int.MAX_VALUE`.

Реализация параллельной весии должна содержаться в функции `shortestPathParallel` в файле `Dijkstra.kt`. Там находится некоторый скелет для будушего алгоритма, но его использование не обязательно и никак не влияет на оценивание.

Если говорить вкратце, то идея параллельного алгоритма заключается в том, что каждый из worker-ов берёт вершину с минимальным расстоянием из приоритетной очереди и релаксирует выходящие из неё ребра; если релаксация прошла успешно (расстояние до вершины на другом конце ребра уменьшили), то добавляем соответствующую вершину в очередь. Из-за того, что вершины обрабатываются параллельно, возможны ситуации, когда они обрабатываются по несколько раз, -- это нормально. 

В качестве многопоточной приоритетной очереди предлагается использовать обычную бинарную кучу с глобальной блокировкой. Вы так же можете изменять класс `Node` по своему усмотрению (добавить блокировку для синхронизации, дополнительную информацию для поддержки операции `decreaseKey`, сделать возможным использование `CAS` на поле `distance` и так далее). Предполагается, что пока очередь пуста, но работа ещё не окончена, worker-ы могут крутиться в цикле в ожидании нового элемента или окончания работы и кушать CPU.



## Решение

Поймем какие проблемы нас встретят, если использовать однопоточную дейкстру из разных потоков, даже если использовать кучу с глобальной блокировкой.

Пусть у нас в графе есть три вершины `v1`, `v2` и `e`, и два ребра `v1 -> e` и `v2 -> e`. Оптимальный путь до `e` пролегает через `v2`. Один поток берет из кучи `v1`, другой - `v2`. Они одновременно релаксят расстояния (но расстояние, которое устанавливает второй поток, меньше). Но первый поток затирает то, что записал второй поток, и поэтому мы попросту теряем оптимальное расстояние до e. Это наводит на мысль о CAS. Для устранения этой проблемы я сделал у `Node` поле `distance` типа `AtomicInteger`, и вместо простого сравнивания и присваивания делаю Compare-And-Set.

Метод `decreaseKey` отсутствует у `PriorityQueue`, так что я использую обычный `add` без `remove`, что никак не мешает алгоритму, и, возможно, работает в целом даже быстрее, чем `add` + `remove`. На рандомных графах так наверняка.

Осталась последняя проблема: когда потокам прекращать работу? Предлагается для каждого потокка завести свой собственный флаг `waiting`, а также общий атомарный счетчик `working`, в котором хранится число потоков, которые могут модифицировать очередь. Другие потоки крутятся в цикле в ожидании нового элемента в `PriorityQueue`. Как только счетчик становится равен 0, все потоки выходят из цикла. Очевидно, подобный подход корректен, ведь счетчик обратится в ноль тогда и только тогда, когда все потоки зайдут в `if (сur == null)`.